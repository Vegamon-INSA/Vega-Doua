import javax.swing.*;
import java.awt.Color;
import java.awt.event.*;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Random;

public class Carte extends GestionCombat implements ActionListener, MouseListener {
	
	private JLabel JLabelPersonnage; //Jlabel image du personnage
	private GestionCombat JFramePrincipal; //Jframe principal avec image de fond
	private int[][] TableauCarte = new int[25][25];//tableau contenenant la consitution de la carte dans laquelle est le personnage
	private int[][] TableauChemin = new int[50][2];//Tableau généré par l'algorithme avec les coordonnées x dans la colonne 0 et y dans la colonne 1 du chemin pour aller d'un point à un autre
	private int[][] TableauCheminTrie = new int[50][2];// Tableau issu du tableau TableauChemin mais qui est cet fois-ci trié dans l'ordre de l'avancement du chemin
	private Timer t1;//Timer de déplacement de 'limage du personnage
	private int a=0;//variable a pour le timer du déplacement du joueur
	private int NbreCases = 25;//nombre de cases dans la grille qui découpe la carte
	
	//coordonnées de départ et d'arrivée
	private int xDepart;
	private int yDepart;
	private int xArrivee;
	private int yArrivee;
	private int NbreDeplacement;
	private int TailleCellule = 600/NbreCases;//Taille d'un carré : largeur de la fenetre divisé par le nombre de cellules
	
	//variables pour l'algorithme de recherche de chemin
	private Node [][] map = new Node[25][25];
	private boolean recherche = true;//Bloque ou pas l'algorithme de recherche de chemin
	private Algorithme AlgoDeplacement = new Algorithme();
	private Random r = new Random();
	private int verifications = 0;//Compteur du nombre de cases vérifiées par l'algorithme de recherche de chemin


	public Carte ( GestionCombat Frame) {
		JFramePrincipal= Frame;
		//Algo de déplacement
		xDepart= JFramePrincipal.xDepart;
		yDepart= JFramePrincipal.yDepart;
		TableauCarte=JFramePrincipal.TableauCarte;
		genererCarteDesMurs();

        //Ajout du fond de la fenetre
        JLabel JLabelCarte = new JLabel (new ImageIcon(JFramePrincipal.imageFond)); 
        JLabelCarte.setBounds(0,0,600,600);
        JLabelCarte.setLayout(null);
        JLabelCarte.addMouseListener(this);
		JFramePrincipal.add(JLabelCarte); 

		// Ajout du Bonhomme à déplacer
        this.JLabelPersonnage = new JLabel(new ImageIcon("Images/Personnagepetit.png")); 
        JLabelPersonnage.setBounds((xDepart*TailleCellule-8),(yDepart*TailleCellule-28),31,52);
        JLabelPersonnage.setLayout(null);
        JLabelCarte.add(JLabelPersonnage);

	}
	
		
	public void mouseClicked(MouseEvent e) {}
	public void mouseEntered(MouseEvent e) {}
	public void mouseExited(MouseEvent e) {}
	public void mouseReleased(MouseEvent e) {}
	public void mousePressed(MouseEvent e) {//quand click sur l'écran
		resetMap();
		try {
			xArrivee = e.getX()/TailleCellule;	//Récupération de l'abscisse et de l'ordonnée du point d'arrivée en fonction de la taille de la grille
			yArrivee = e.getY()/TailleCellule;
			System.out.println("xArrivee="+xArrivee);
			System.out.println(yArrivee);
			Node current = map[xArrivee][yArrivee];
			DeplacementJoueur (xArrivee,yArrivee);
			System.out.println("Deplacement terminé");
		} catch(Exception z) {}	//catch les exceptions
	}
	

	public void resetMap() {	//reset du tableau de recherche du chemin
		for(int x = 0; x < NbreCases; x++) {
			for(int y = 0; y < NbreCases; y++) {
				Node current = map[x][y];
				if(current.getType() == 4 || current.getType() == 5)	//check si le node est le cehmin fianl ou le début ou l'arrivée
					map[x][y] = new Node(3,x,y);	//Si ce n'est pas le cas : on vide la case
			}
		}
		//reset les cases de début et de fin
		if(xDepart > -1 && yDepart > -1) {	
			map[xDepart][yDepart] = new Node(0,xDepart,yDepart);
			map[xDepart][yDepart].setesperance(0);
		}
		if(xArrivee > -1 && yArrivee > -1)
			map[xArrivee][yArrivee] = new Node(1,xArrivee,yArrivee);
		resetVariablesAlgo();	
		
		for(int s = 0; s < TableauChemin.length; s++) {
			TableauCheminTrie[s][0]=0;
			TableauCheminTrie[s][1]=0;

		}
	}
		
	
	public boolean PossibiliteDeplacement (int x, int y){ // Test si la poistion finale demandée lors du click est possible	
        boolean possibilite = true;
        if ((TableauCarte[y][x] == 0) || (TableauCarte[y][x] == 6)){
            possibilite=false;
        }
        System.out.println(possibilite);
        return possibilite;
    }
    

    public void DeplacementJoueur (int xFinal, int yFinal){
		if (PossibiliteDeplacement(xFinal,yFinal)){// Test si la poistion finale demandée est possible	
			genererCarteDesMurs();
			resetMap();
			demarrerRecherche();
			int colonneY=0;
			for(int x = 0; x < NbreCases; x++) {	
				for(int y = 0; y < NbreCases; y++) {
					if (map[x][y].getType()==5){
						TableauChemin[colonneY][0]=map[x][y].getX();
						TableauChemin[colonneY][1]=map[x][y].getY();
						colonneY++;
					}
				}
			}
			TriTableauChemin();
			t1= new Timer(1000, this);
			t1.start();	
			xDepart=TableauCheminTrie[NbreDeplacement][0]/TailleCellule;
			yDepart=TableauCheminTrie[NbreDeplacement][1]/TailleCellule;
		}
	}
	

	public void TriTableauChemin(){//retirer les System.out.println pour nettoyer
		boolean finDuTri=false;
		NbreDeplacement=0;
		System.out.println("Tableau initial :");
		for(int s = 0; s < TableauChemin.length; s++) {	
			System.out.println(TableauChemin[s][0]+"=x, y="+TableauChemin[s][1]);
		}
        TableauCheminTrie[0][0]=xDepart;
        TableauCheminTrie[0][1]=yDepart;
        for (int j=0; j<TableauChemin.length; j++) {
			if ((TableauChemin[j][0]==xDepart) && (TableauChemin[j][1]==yDepart)){
				TableauChemin[j][0]=0;
				TableauChemin[j][1]=0;	
			}
		}
		for (int d=0; d<(TableauChemin.length-1); d++){
			if (finDuTri==true){
				System.out.println("Fin du tri");
				break;
			}
			System.out.println("d="+d);
			int w=0;
			while (TableauCheminTrie[d+1][0]==0){
				if((TableauCheminTrie[d][0]==TableauChemin[w][0]) && ((TableauCheminTrie[d][1]==(TableauChemin[w][1]+1)) || (TableauCheminTrie[d][1]==TableauChemin[w][1]-1))){
					System.out.println("Déplacement vertcal");					
					TableauCheminTrie[d+1][0]=TableauChemin[w][0];
					TableauCheminTrie[d+1][1]=TableauChemin[w][1];
				}
				else if((TableauCheminTrie[d][1]==TableauChemin[w][1]) && ((TableauCheminTrie[d][0]==(TableauChemin[w][0]+1)) || (TableauCheminTrie[d][0]==TableauChemin[w][0]-1))){
					System.out.println("Déplacement horizontal");				
					TableauCheminTrie[d+1][0]=TableauChemin[w][0];
					TableauCheminTrie[d+1][1]=TableauChemin[w][1];
				}
						/*System.out.println(TableauCheminTrie[d][1]);
						System.out.println(TableauChemin[w][1]+1);
						System.out.println(TableauChemin[w][1]-1);
						//System.out.println((TableauCheminTrie[d][1]!=(TableauChemin[x][1]+1)) && (TableauCheminTrie[d][1]!=TableauChemin[x][1]-1));
						System.out.println(TableauCheminTrie[d][0]);
						System.out.println(TableauChemin[w][0]+1);
						System.out.println(TableauChemin[w][0]-1);
						//System.out.println((TableauCheminTrie[d][0]!=(TableauChemin[x][0]+1)) && (TableauCheminTrie[d][0]!=(TableauChemin[x][0]-1)));*/
				else if(!( ( (TableauCheminTrie[d][1]!=(TableauChemin[w][1]+1)) && (TableauCheminTrie[d][1]!=(TableauChemin[w][1]-1)) ) || ( (TableauCheminTrie[d][0]!=(TableauChemin[w][0]+1)) && (TableauCheminTrie[d][0]!=(TableauChemin[w][0]-1) ) ) )){
						System.out.println("Déplacement diagonal");
						TableauCheminTrie[d+1][0]=TableauChemin[w][0];
						TableauCheminTrie[d+1][1]=TableauChemin[w][1];
				}				
				w++;
			}
			for(int h = 0; h < TableauCheminTrie.length; h++) {	
				System.out.println("Tableau trié : x= "+TableauCheminTrie[h][0]+" y= "+TableauCheminTrie[h][1]);
			}
			TableauChemin[w-1][0]=0;
			TableauChemin[w-1][1]=0;

			for(int s = 0; s < TableauChemin.length; s++) {
				if((TableauChemin[s][0]==0)&&(TableauChemin[s][1]==0)){
					finDuTri=true;
				}
				else {
					finDuTri=false;
					break;
				}
			}
		}
		System.out.println("Tableau initial :");
		for(int s = 0; s < TableauChemin.length; s++) {
			System.out.println(TableauChemin[s][0]+"=x,oui y="+TableauChemin[s][1]);
			if((TableauCheminTrie[s][0]!=0)&&(TableauCheminTrie[s][1]!=0)){
				NbreDeplacement++;
			}
		}
		TableauCheminTrie[NbreDeplacement][0]=xArrivee;
		TableauCheminTrie[NbreDeplacement][1]=yArrivee;
		System.out.println("NbreDeplacement ="+NbreDeplacement);		
		for(int h = 0; h < TableauCheminTrie.length; h++) {	
			TableauCheminTrie[h][0]=TableauCheminTrie[h][0]*TailleCellule;
			TableauCheminTrie[h][1]=TableauCheminTrie[h][1]*TailleCellule;
			System.out.println(TableauCheminTrie[h][0]+"=x, y="+TableauCheminTrie[h][1]);
		}
	}

	
	public void actionPerformed(ActionEvent u) {//Timer délpacement personnage
		if(u.getSource()==t1){
			t1.stop();
			DeplacementImage();
			t1= new Timer(300, this);
			if (a<NbreDeplacement){
				t1.start();
				a++;
			}
		}	 
	}		
		

	public void DeplacementImage() {//Déplacement du Bonhomme
		if((TableauCheminTrie[a][0]!=0)&&(TableauCheminTrie[a][1]!=0)){
			JLabelPersonnage.setBounds((TableauCheminTrie[a][0]-8),(TableauCheminTrie[a][1]-28),31,52);
		}
	}


    public void viderCarte() {	//vide le tableau de l'algorithme de recherche de chemin
		for(int x = 0; x < 25; x++) {
			for(int y = 0; y < 25; y++) {
				map[x][y] = new Node(3,x,y);//On vide tous les Nodes 
			}
		}
		resetVariablesAlgo();

	}
	
	
	public void genererCarteDesMurs() {	//genère le tableau des murs pour l'algorithme de recherche de chemin
		viderCarte();//On vide entièrement le tableau
		for(int i = 0; i < 25; i++) {
            for(int j = 0; j < 25; j++) {
                Node current;
                current = map[i][j];
                if (!((TableauCarte[j][i]==4) || (TableauCarte[j][i] == 1) || (TableauCarte[j][i]==5))){//On ajoute les murs sinon on laisse vide
					current.setType(2);
                }  
            }
		}
	}
	
	
	public void demarrerRecherche() {	//Démarrer la recherche
		if(recherche) {
			AlgoDeplacement.AlgorithmeAEtoile();
		}
	}


	public void resetVariablesAlgo() {	//reset les variables de l'algorithme de recherche du chemin
		recherche = true;
		verifications = 0;
		a=0;
	}


	class Algorithme {	//Classe de l'algorithme de déplacement

		public void AlgorithmeAEtoile() {
			ArrayList<Node> priorite = new ArrayList<Node>();
			priorite.add(map[xDepart][yDepart]);
			while(recherche) {
				if(priorite.size() <= 0) {
					recherche = false;
					break;
				}
				int esperance = priorite.get(0).getesperance()+1;
				ArrayList<Node> DejaVisite = explorerVoisins(priorite.get(0),esperance);
				if(DejaVisite.size() > 0) {
					priorite.remove(0);
					priorite.addAll(DejaVisite);
				} else {
					priorite.remove(0);
				}
				Tri(priorite);	//tri des priorités
			}
		}
		
		
		public ArrayList<Node> Tri(ArrayList<Node> listeTriee) {	//Tri de la liste des priorités
			int c = 0;
			while(c < listeTriee.size()) {
				int sm = c;
				for(int i = c+1; i < listeTriee.size(); i++) {
					if(listeTriee.get(i).getEuclidDist()+listeTriee.get(i).getesperance() < listeTriee.get(sm).getEuclidDist()+listeTriee.get(sm).getesperance())
						sm = i;
				}
				if(c != sm) {
					Node temp = listeTriee.get(c);
					listeTriee.set(c, listeTriee.get(sm));
					listeTriee.set(sm, temp);
				}	
				c++;
			}
			return listeTriee;
		}
		
		
		public ArrayList<Node> explorerVoisins(Node current, int esperance) {	//EXPLORE voisins
			ArrayList<Node> DejaVisite = new ArrayList<Node>();	//LIST OF NODES THAT HAVE BEEN DejaVisite
			for(int a = -1; a <= 1; a++) {
				for(int b = -1; b <= 1; b++) {
					int xbound = current.getX()+a;
					int ybound = current.getY()+b;
					if((xbound > -1 && xbound < NbreCases) && (ybound > -1 && ybound < NbreCases)) {	//MAKES SURE THE NODE IS NOT OUTSIDE THE GRID
						Node voisin = map[xbound][ybound];
						if((voisin.getesperance()==-1 || voisin.getesperance() > esperance) && voisin.getType()!=2) {	//CHECKS IF THE NODE IS NOT A WALL AND THAT IT HAS NOT BEEN DejaVisite
							explore(voisin, current.getX(), current.getY(), esperance);	//EXPLORE THE NODE
							DejaVisite.add(voisin);	//ADD THE NODE TO THE LIST
						}
					}
				}
			}
			return DejaVisite;
		}
		
		
		public void explore(Node current, int lastx, int lasty, int esperance) {	//EXPLORE A NODE
			if(current.getType()!=0 && current.getType() != 1)	//CHECK THAT THE NODE IS NOT THE START OR FINISH
				current.setType(4);	//SET IT TO DejaVisite
			current.setLastNode(lastx, lasty);	//KEEP TRACK OF THE NODE THAT THIS NODE IS DejaVisite FROM
			current.setesperance(esperance);	//SET THE esperance FROM THE START
			verifications++;
			if(current.getType() == 1) {	//IF THE NODE IS THE FINISH THEN BACKTRACK TO GET THE PATH
				backtrack(current.getLastX(), current.getLastY(),esperance);
			}
		}
		
		
		public void backtrack(int lx, int ly, int esperance) {	//BACKTRACK
			while(esperance > 1) {	//BACKTRACK FROM THE END OF THE PATH TO THE START
				Node current = map[lx][ly];
				current.setType(5);
				lx = current.getLastX();
				ly = current.getLastY();
				esperance--;
			}
			recherche = false;
		}
	}
	
	
	class Node {
		
		// 0 = start, 1 = finish, 2 = wall, 3 = empty, 4 = checked, 5 = finalpath
		private int cellType = 0;
		private int esperance;
		private int x;
		private int y;
		private int lastX;
		private int lastY;
		private double dToEnd = 0;
	
		public Node(int type, int x, int y) {	//CONSTRUCTOR
			cellType = type;
			this.x = x;
			this.y = y;
			esperance = -1;
		}
		
		public double getEuclidDist() {		//CALCULATES THE EUCLIDIAN DISTANCE TO THE FINISH NODE
			int xdif = Math.abs(x-xArrivee);
			int ydif = Math.abs(y-yArrivee);
			dToEnd = Math.sqrt((xdif*xdif)+(ydif*ydif));
			return dToEnd;
		}
		
		public int getX() {return x;}		//GET METHODS
		public int getY() {return y;}
		public int getLastX() {return lastX;}
		public int getLastY() {return lastY;}
		public int getType() {return cellType;}
		public int getesperance() {return esperance;}
		
		public void setType(int type) {cellType = type;}		//SET METHODS
		public void setLastNode(int x, int y) {lastX = x; lastY = y;}
		public void setesperance(int esperance) {this.esperance = esperance;}
	}
}


		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
	
	









